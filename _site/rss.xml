<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
<channel>
        <title>Brady 丶 一点一滴</title>
        <description>Brady 丶 一点一滴 - yutengwan</description>
        <link>http://yutengwan.github.io</link>
        <link>http://yutengwan.github.io</link>
        <lastBuildDate>2015-01-29T19:43:01+08:00</lastBuildDate>
        <pubDate>2015-01-29T19:43:01+08:00</pubDate>
        <ttl>1800</ttl>


        <item>
                <title>vim</title>
                <description>&lt;h3&gt;基本命令&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;dd&lt;/code&gt; 删除一行&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;fa&lt;/code&gt; 光标挪到下一个字母a的位置&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;dfa&lt;/code&gt; 删除从当前光标到下一个字母a之间的所有内容&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;0&lt;/code&gt; 数字零，到行头&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;^&lt;/code&gt; 到本行第一个不是blank字符的位置(blank字符就是空格，tab，换行，回车等)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;$&lt;/code&gt;到本行末尾&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;g_&lt;/code&gt;到本行最后一个不是blank字符的位置&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;/pattern&lt;/code&gt; 搜索pattern的字符串&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;u&lt;/code&gt; 回退&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;lt;C -r&amp;gt;&lt;/code&gt; 前进&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;e &amp;lt;path&amp;gt;&lt;/code&gt; 打开一个文件&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;.&lt;/code&gt; 重复上个命令&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;N &amp;lt;command&amp;gt;&lt;/code&gt; 重复某个命令N次&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;ndd&lt;/code&gt; 删除n行&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;w&lt;/code&gt; 到下一个单词开头&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;e&lt;/code&gt; 到下一个单词结尾&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;*,#&lt;/code&gt;匹配光标当前所在的单词(&lt;code&gt;*&lt;/code&gt;下一个，&lt;code&gt;#&lt;/code&gt;上一个)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;t,&lt;/code&gt;到&lt;code&gt;,&lt;/code&gt;前的第一个字符，&lt;code&gt;,&lt;/code&gt;可以换成其他的字符&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;a&lt;/code&gt; 在当前光标位置插入&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;o&lt;/code&gt; 在下一行开始插入&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;O&lt;/code&gt; 在光标的上一行插入&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;cw&lt;/code&gt; 替换当前光标的word，并插入&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;:e&lt;/code&gt; 打开文件&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;:saveas &amp;lt;path/to/file&amp;gt;&lt;/code&gt; 另存为&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;参照：&lt;a href=&quot;http://yannesposito.com/Scratch/en/blog/Learn-Vim-Progressively/&quot;&gt;http://yannesposito.com/Scratch/en/blog/Learn-Vim-Progressively/&lt;/a&gt;&lt;/p&gt;
</description>
                <link>http://yutengwan.github.io/2015/01/29/vim</link>
                <guid>http://yutengwan.github.io/2015/01/29/vim</guid>
                <pubDate>2015-01-29T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>HTTPError</title>
                <description>&lt;h3&gt;HTTPClientError&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;400&lt;/code&gt;  HTTPBadRequest&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;401&lt;/code&gt;  HTTPUnauthorized&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;402&lt;/code&gt;  HTTPPaymentRequired&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;403&lt;/code&gt;  HTTPForbidden&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;404&lt;/code&gt; HTTPNotFound&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;405&lt;/code&gt; HTTPMethodNotAllowed&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;406&lt;/code&gt; HTTPNotAcceptable&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;407&lt;/code&gt; HTTPProxyAuthenticationRequired&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;408&lt;/code&gt; HTTPRequestTimeout&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;409&lt;/code&gt; HTTPConfict&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;410&lt;/code&gt; HTTPGone&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;411&lt;/code&gt; HTTPLengthRequired&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;412&lt;/code&gt; HTTPProconditionFailed&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;413&lt;/code&gt; HTTPRequestEntityToolLarge&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;414&lt;/code&gt; HTTPRequestURITooLong&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;415&lt;/code&gt; HTTPUnsupportedediaType&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;416&lt;/code&gt; HTTPRequestRangeNotSatisfiable&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;417&lt;/code&gt; HTTPExceptionFailed&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;HTTPServerError&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;500&lt;/code&gt; HTTPInternalServerError&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;501&lt;/code&gt; HTTPNotImplemented&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;502&lt;/code&gt; HTTPBadGateway&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;503&lt;/code&gt; HTTPServiceUnavailable&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;504&lt;/code&gt; HTTPGatewayTimeout&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;505&lt;/code&gt; HTTPVersionNotSupported&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
                <link>http://yutengwan.github.io/2015/01/29/httpError</link>
                <guid>http://yutengwan.github.io/2015/01/29/httpError</guid>
                <pubDate>2015-01-29T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>tar</title>
                <description>&lt;ul&gt;
&lt;li&gt;&lt;code&gt;tar -czvf test.tar.gz test&lt;/code&gt;  将test文件夹打包压缩&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tar zxvf test.tar.gz&lt;/code&gt;        解压&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tar -tf test.tar.gz&lt;/code&gt;         查看包里面的文件信息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tar -cf test.tar *.jpg&lt;/code&gt;      将当前目录所有.jpg文件打包成一个test.tar文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tar -rf test.tar *.gif&lt;/code&gt;      将所有.gif文件增加到test.tar的包里面&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tar -uf test.tar logo.gif&lt;/code&gt;   更新原来tar包test.tar中logo.gif文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tar -xf test.tar&lt;/code&gt;            解出test.tar包中所有文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tar -cjf test.tar.bz2 *.jpg&lt;/code&gt; 压缩成.bz2的压缩文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tar -xjf test.tar.bz2&lt;/code&gt;       解压.bz2文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tar -cZf test.tar.Z *.jpg&lt;/code&gt;   压缩成.Z的压缩文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tar -xZf all.tar.Z&lt;/code&gt;          解压.Z文件&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;tar 主要模式&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-A --catenate&lt;/code&gt;   追加tar文件至归档&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-c --create&lt;/code&gt;     创建一个新归档&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-d --diff&lt;/code&gt;       找出归档文件和文件系统的差异&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-r --append&lt;/code&gt;     追加文件到 归档结尾&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-t --list&lt;/code&gt;       列出归档内容&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-u --update&lt;/code&gt;     仅追加比归档中副本更新的文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-x --extract&lt;/code&gt;    从归档中解出文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-f --file&lt;/code&gt;       指定归档文件&lt;/li&gt;
&lt;/ul&gt;

</description>
                <link>http://yutengwan.github.io/2015/01/27/tar</link>
                <guid>http://yutengwan.github.io/2015/01/27/tar</guid>
                <pubDate>2015-01-27T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>gcc</title>
                <description>&lt;h3&gt;gcc基本用法&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;gcc -g -Wall main.c -o main
./main
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;-Wall&lt;/code&gt;开启编译器几乎所有常用的警告(推荐使用此选项)&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-g&lt;/code&gt; 生成的目标文件中带调试信息，调试信息可以在程序异常中止产生core后，帮助分析错误产生的源头，包括产生错误的文件名和行号等非常多有用的信息。&lt;/p&gt;

&lt;p&gt;c/c++编程相关文件后缀：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.a&lt;/code&gt;静态库(archive)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.i&lt;/code&gt;源代码(不需要编译预处理)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.o&lt;/code&gt;对象文件  &lt;code&gt;gcc -c main.c -o main.o&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.s&lt;/code&gt;汇编语言代码&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.so&lt;/code&gt;动态库   &lt;code&gt;gcc -Wall -shared *.o -o main.so&lt;/code&gt;  &lt;code&gt;gcc -Wall -fpic -shared *.c -o main.so&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.cpp,.cc,.ii&lt;/code&gt; C++文件&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;使用动态库 &lt;code&gt;gcc -Wall useMain.c main.so -o useMain&lt;/code&gt;&lt;/p&gt;
</description>
                <link>http://yutengwan.github.io/2015/01/27/gcc</link>
                <guid>http://yutengwan.github.io/2015/01/27/gcc</guid>
                <pubDate>2015-01-27T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>yii RBAC</title>
                <description>&lt;p&gt;在权限控制过程中，会有一个默认的角色在:&lt;code&gt;CAuthManager::defaultRoles&lt;/code&gt;属性中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;php&quot;&gt;return array(
    &#39;components&#39;=&amp;gt;array(
        &#39;authManager&#39;=&amp;gt;array(
            &#39;class&#39;=&amp;gt;&#39;CDbAuthManager&#39;,
            &#39;defaultRoles&#39;=&amp;gt;array(&#39;user&#39;),
        ),
    ),
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;默认角色会分配给每个用户，所以在定义Role时一般都会确定一下是否应用到用户&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;php&quot;&gt;$bizRule = &#39;return Yii::app()-&amp;gt;user-&amp;gt;isUser()&#39;;   //isUser()在WebUser.php中定义
$auth-&amp;gt;createRole(&#39;user&#39;,&#39;normal user&#39;,$bizRule);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在使用$bizRule中的规则时，切记&lt;code&gt;return ...;&lt;/code&gt;,后面的分号一定要写，我就是被这个小问题坑了老长时间的&lt;/p&gt;

&lt;p&gt;还有在使用这个checkAccess中用户角色时，他都是从auth_assignment表中获取表的角色，不能通过外部判断结构进行判断，比如：&lt;code&gt;$role = $auth-&amp;gt;createRole(&#39;root&#39;,&#39;超级管理员&#39;,&#39;return Yii::app()-&amp;gt;user-&amp;gt;isRoot()&#39;);&lt;/code&gt; 这种情况在&lt;code&gt;Yii::app()-&amp;gt;user-&amp;gt;checkAccess(&#39;root&#39;)&lt;/code&gt;判断永远是false的，它会先从auth_assignment表中获取角色对象：&lt;/p&gt;

&lt;p&gt;yii中checkAccess部分源码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;php&quot;&gt;public function checkAccess($itemName,$userId,$params=array()) {
    $assignments=$this-&amp;gt;getAuthAssignments($userId);
    return $this-&amp;gt;checkAccessRecursive($itemName,$userId,$params,$assignments);
}

public function getAuthAssignment($itemName,$userId){
    $row=$this-&amp;gt;db-&amp;gt;createCommand()
        -&amp;gt;select()
        -&amp;gt;from($this-&amp;gt;assignmentTable)
        -&amp;gt;where(&#39;itemname=:itemname AND userid=:userid&#39;, array(
            &#39;:itemname&#39;=&amp;gt;$itemName,
            &#39;:userid&#39;=&amp;gt;$userId))
        -&amp;gt;queryRow();
    if($row!==false){
        if(($data=@unserialize($row[&#39;data&#39;]))===false)
            $data=null;
        return new CAuthAssignment($this,$row[&#39;itemname&#39;],$row[&#39;userid&#39;],$row[&#39;bizrule&#39;],$data);
    }
    else
        return null;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同时在使用RBAC时，如果想要实现动态的切换权限的设置，则需要在外部接口判断该用户是否为root，user可以在WebUser中进行切换对象&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;php&quot;&gt;&amp;lt;?php
public function changeRole($role = null) {
    $role = strtolower($role);
    if (($role == &#39;user&#39;) || ($role == &#39;root&#39; &amp;amp;&amp;amp; $this-&amp;gt;isAdmin())) {           /
        $userID = Yii::app()-&amp;gt;user-&amp;gt;getId();
        $auth = Yii::app()-&amp;gt;authManager;
        if ($auth-&amp;gt;isAssigned($this-&amp;gt;getRole(),$userID)) {
            $auth-&amp;gt;revoke($this-&amp;gt;getRole(),$userID);
            $auth-&amp;gt;assign($role,$userID);   
        } esle {
            $auth-&amp;gt;assign($role,$userID);
        }
    }
}
?&amp;gt;

这个isAdmin()是指在外部判断该用户的最高权限，这样就可切换到它的下面的权限浏览
$this-&amp;gt;getRole = $this-&amp;gt;getState(&#39;-role&#39;);
$auth的其他方法可以查看yii提供的函数
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里就是通过对auth_assignment数据库表的修改实现动态切换用户的权限的  &lt;a href=&quot;https://github.com/yiisoft/yii/tree/1.1.16/framework/web/auth&quot;&gt;yii AuthManager&lt;/a&gt;&lt;/p&gt;
</description>
                <link>http://yutengwan.github.io/2015/01/26/yii_RBAC</link>
                <guid>http://yutengwan.github.io/2015/01/26/yii_RBAC</guid>
                <pubDate>2015-01-26T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>makefile</title>
                <description>&lt;blockquote&gt;&lt;p&gt;makefile主要是把需要编译的源文件的命令集合到一个文件中，这样就不需要每次都把文件依次编译一遍，而只需执行这个文件就可以一次性编译,生成可执行文件。其实也可以看作成一个shell命令&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;同时他也定义了一系列的规则，
比如先编译文件的先后顺序，它实现的是&lt;code&gt;自动化编译过程&lt;/code&gt;,一旦写好了，只需一个make命令，整个工程就自动编译，提供了我们开发的效率(但是再windows下没有这个工具，因为我们的IDE已经为我们做了这一步)。&lt;/p&gt;

&lt;p&gt;这里的话，可以说一下代码编译过程，对于c/c++程序首先需要将源文件编译成中间目标代码文件(.o object file)，这个就是&lt;code&gt;编译(compile)&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;然后把大量的Object file合成可执行文件，这个动作就是&lt;code&gt;链接(link)&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;在链接时，主要是链接函数和全局变量，故我们使用这些中间代码文件来链接我们的应用程序。在链接的时候连接器不管函数所在的源文件，只管函数的中间目标文件，在大多数情况下，源文件太多，编译生成的中间目标文件太多，而在链接时，需要明显地指出中间目标文件名，但是由于编译的不方便，一般的话都会给中间目标文件打个包，在windows下就是&lt;code&gt;库文件(.lib library file)&lt;/code&gt;，在unix下是&lt;code&gt;.a Archive file&lt;/code&gt;。&lt;/p&gt;

&lt;h3&gt;makefile的一些基本规则&lt;/h3&gt;

&lt;p&gt;makefile文件有三部分：
- target：目标文件，就是最后的执行文件
- prerequisite：要生成target所需要的文件或是目标(依赖文件)
- command：make需要执行的命令&lt;/p&gt;

&lt;p&gt;例如下面一个工程里有三个头文件，8个c文件&lt;/p&gt;

&lt;p&gt;defs.h.command.h,buffer.h&lt;/p&gt;

&lt;p&gt;main.c,kdb.c,command.c,display.c,insert.c,search.c,files.c,utils.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;makefile&quot;&gt;edit : main.o,kdb.o,command.o,display.o,insert.o,\ 
        search.o,files.o,utils.o                      /*如果后面这些.o文件比edit可执行文件新,那么才会去执行下面这句命令*/
        gcc -o edit main.o,kdb.o,command.o,display.o,insert.o,\ 
        search.o,files.o,utils.o
main.o : main.c defs.h
        gcc -c main.c
kdb.o : kdb.c defs.h
        gcc -c kdb.c
command.o : command.c defs.h command.h
        gcc -c command.c
display.o : display.c defs.h buffer.h
        gcc -c display.c
insert.o : insert.c defs.h buffer.h
        gcc -c insert.c
search.o : search.c defs.h buffer.h
        gcc -c search.c
files.o : files.c defs.h buffer.h command.h
        gcc -c files.c
utils.o : utils.c defs.h
        gcc -c utils.c

clean:
        rm edit main.o,kdb.o,command.o,display.o,insert.o,\
        search.o,files.o,utils.o
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段makefile的只有执行make就会生成执行文件edit，如果需要删除中间目标文件只需执行make clean&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;target：edit和中间目标文件(*.o)&lt;/li&gt;
&lt;li&gt;prerequisite：冒号(:)后面的.c和.h文件&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;make工作流程&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;make会在当前目录下找名字为&lt;code&gt;Makefile&lt;/code&gt;或&lt;code&gt;makefile&lt;/code&gt;文件&lt;/li&gt;
&lt;li&gt;如果找到，找到文件中的第一个目标文件(target)，如上面例子:edit文件&lt;/li&gt;
&lt;li&gt;如果edit文件不存在，或者edit所依赖的后面的.o文件的文件修改时间比edit这个文件新，那么，他就执行后面需要的命令生成edit文件&lt;/li&gt;
&lt;li&gt;如果edit所依赖的.o文件也不存在，那么make会在当前文件中找目标为.o文件的依赖性，如果找到则会根据依赖关系生成.o文件&lt;/li&gt;
&lt;li&gt;当你的C文件和H文件都存在时，于是make会生成.o文件，然后再用.o文件生成make的最终可执行文件edit&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;这就是整个make的依赖性，make会一层又一层地去找文件的依赖关系，直到最终编译出第一个目标文件。在找寻的过程中，如果出现错误，比如最后被依赖的文件找不到，那么make就会直接退出，并报错，而对于所定义的命令的错误，或是编译不成功，make根本不理。make只管文件的依赖性，即，如果在我找了依赖关系之后，冒号后面的文件还是不在，那还是会直接退出。&lt;/p&gt;

&lt;p&gt;在编译通过之后，当我们修改了其中一个源文件，比如files.c文件，那么根据我们的依赖关系，我们的目标文件files.o会重新编译一遍，于是files.o是最新的，但是edit还不是最新，所有edit也会重新链接。&lt;/p&gt;

&lt;p&gt;如果我们修改了&quot;command.h&quot;,那么kdb.o,command.o,files.o都会重新编译，并且edit会重新链接。&lt;/p&gt;

&lt;h3&gt;makefile中的变量&lt;/h3&gt;

&lt;p&gt;在makefile中一些文件需要被重复使用，那么我们就可以使用变量来对他们进行声明和使用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;makefile&quot;&gt;objects = main.o kbd.o command.o display.o\
          insert.o search.o files.o utils.o
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在使用变量之后一些表达式就可以变得非常简单可用了，在makefile里面使用变量以&lt;code&gt;$(objects)&lt;/code&gt;这种方式来使用变量。下面我们就可以把上面的例子简写成：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;makefile&quot;&gt;objects = main.o,kdb.o,command.o,display.o,\
          insert.o, search.o,files.o,utils.o 
edit : $(objects)
        gcc -o edit $(objects)
main.o : main.c defs.h
        gcc -c main.c
kdb.o : kdb.c defs.h
        gcc -c kdb.c
command.o : command.c defs.h command.h
        gcc -c command.c
display.o : display.c defs.h buffer.h
        gcc -c display.c
insert.o : insert.c defs.h buffer.h
        gcc -c insert.c
search.o : search.c defs.h buffer.h
        gcc -c search.c
files.o : files.c defs.h buffer.h command.h
        gcc -c files.c
utils.o : utils.c defs.h
        gcc -c utils.c

clean:
        rm edit $(objects)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;makefile 自动推导功能&lt;/h3&gt;

&lt;p&gt;GNU的make很强大，它可以自动推导文件以及文件依赖关系后面的命令，于是我们就没必要去在每一个[.o]文件后都写上类似的命令，因为，我们的make会自动识别，并自己推导命令。&lt;/p&gt;

&lt;p&gt;只要make看到一个[.o]文件，它就会自动的把[.c]文件加在依赖关系中，如果make找到一个whatever.o，那么 whatever.c，就会是whatever.o的依赖文件。并且 cc -c whatever.c 也会被推导出来，于是，我们的makefile 再也不用写得这么复杂。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;makefile&quot;&gt;objects = main.o,kdb.o,command.o,display.o,\
          insert.o, search.o,files.o,utils.o 
edit : $(objects)
        gcc -o edit $(objects)
main.o : defs.h
kdb.o : defs.h
command.o : defs.h command.h
display.o : defs.h buffer.h
insert.o : defs.h buffer.h
search.o : defs.h buffer.h
files.o : defs.h buffer.h command.h
utils.o : defs.h

.PHONE : clean
clean:
        rm edit $(objects)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;.PHONE&lt;/code&gt;表示clean是一个伪目标文件&lt;/p&gt;

&lt;h3&gt;makefile文件里有什么&lt;/h3&gt;

&lt;p&gt;makefile文件主要有5个东西：显式规则，隐晦规则，变量定义，文件指示和注释。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;显式规则：显式规则说明了，如何生成一个或多个目标文件。这是由Makefile的书写者明显指出，要生成的文件，文件的依赖文件，生成的命令。&lt;/li&gt;
&lt;li&gt;隐晦规则：由于我们的make有自动推导的功能，所以隐晦的规则可以让我们比较简略地书写Makefile，这是由make所支持的。&lt;/li&gt;
&lt;li&gt;变量的定义：在Makefile中我们要定义一系列的变量，变量一般都是字符串，这个有点像你C语言中的宏，当Makefile被执行时，其中的变量都会被扩展到相应的引用位置上。&lt;/li&gt;
&lt;li&gt;文件指示：其包括了三个部分，一个是在一个Makefile中引用另一个Makefile，就像C语言中的include一样；另一个是指根据某些情况指定Makefile中的有效部分，就像C语言中的预编译#if一样；还有就是定义一个多行的命令。有关这一部分的内容，我会在后续的部分中讲述。&lt;/li&gt;
&lt;li&gt;注释：Makefile中只有行注释，和UNIX的Shell脚本一样，其注释是用“#”字符，这个就像C/C++中的“//”一样。如果你要在你的Makefile中使用“#”字符，可以用反斜杠进行转义，如：“#”。&lt;/li&gt;
&lt;/ol&gt;


&lt;blockquote&gt;&lt;p&gt;另外：在Makefile中的命令，必须要以&lt;code&gt;Tab&lt;/code&gt;键开始。&lt;/p&gt;&lt;/blockquote&gt;

&lt;h3&gt;引用其他的MakeFile&lt;/h3&gt;

&lt;p&gt;在Makefile使用include关键字可以把别的Makefile包含进来，这很像C语言的#include，被包含的文件会原模原样的放在当前文件的包含位置。include的语法是：
&lt;code&gt;makefile
include &amp;lt;filename&amp;gt;
&lt;/code&gt;
在include前面可以有一些空字符，但是绝不能是[Tab]键开始。include和&lt;filename&gt;;可以用一个或多个空格隔开。举个例子，你有这样几个Makefile：a.mk,b.mk,c.mk，还有一个文件叫foo.make，以及一个变量$(bar)，其包含了 e.mk和f.mk，那么，下面的语句：
&lt;code&gt;makefile
include foo.make *.mk $(bar)
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;等价于：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;makefile&quot;&gt;include foo.make a.mk b.mk c.mk e.mk f.mk
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;make的工作方式：&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;读入所有的makefile&lt;/li&gt;
&lt;li&gt;读入被include的其他的makefile&lt;/li&gt;
&lt;li&gt;初始化文件中的变量&lt;/li&gt;
&lt;li&gt;推导隐晦规则，并分析所有规则&lt;/li&gt;
&lt;li&gt;为所有的目标文件创建依赖关系链&lt;/li&gt;
&lt;li&gt;根据依赖关系，决定哪些目标要重新生成&lt;/li&gt;
&lt;li&gt;执行生成命令&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;1-5步为第一个阶段，6-7为第二个阶段。第一个阶段中，如果定义的变量被使用了，那么，make会把其展开在使用的位置。但make并不会完全马上展开，make使用的是拖延战术，如果变量出现在依赖关系的规则中，那么仅当这条依赖被决定要使用了，变量才会在其内部展开。&lt;/p&gt;

&lt;p&gt; &lt;a href=&quot;http://wiki.ubuntu.org.cn/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile&quot;&gt;参考&lt;/a&gt;&lt;/p&gt;
</description>
                <link>http://yutengwan.github.io/2015/01/25/makefile</link>
                <guid>http://yutengwan.github.io/2015/01/25/makefile</guid>
                <pubDate>2015-01-25T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>svn status的各种状态的说明</title>
                <description>&lt;h3&gt;svn status:&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;U:&lt;/strong&gt; working file was uploaded,工作目录更新&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;G:&lt;/strong&gt; Changes on the repo were automatically merged into the working copy，版本自动merge上去&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;M:&lt;/strong&gt; Working copy is modify,文件修改&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;C:&lt;/strong&gt; The file conflicts with the version in the repo文件在版本库中冲突&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;?:&lt;/strong&gt; The file is not under version control 文件不在版本库中&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;!:&lt;/strong&gt; The file is under version control but is missing or incomplete 文件在版本库中，但是没有使用svn删除或不完整&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;A:&lt;/strong&gt; The file will be added to version control(after commit)新增文件&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;A+:&lt;/strong&gt; The file will be moved (after commit)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;D:&lt;/strong&gt;  The file will be deleted (after commit)文件被移除版本库&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;S:&lt;/strong&gt;  This signifies that the file or directory has been switched from the path of the rest of the working copy (using svn switch) to a branch&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;I:&lt;/strong&gt; Ignored&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;R:&lt;/strong&gt; Item has been replaced in your working copy. This means the file was scheduled for deletion, and then a new file with the same name was scheduled for addition in its place.&lt;/p&gt;
</description>
                <link>http://yutengwan.github.io/2015/01/23/svn_status</link>
                <guid>http://yutengwan.github.io/2015/01/23/svn_status</guid>
                <pubDate>2015-01-23T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>进程的状态</title>
                <description>&lt;h2&gt;Linux 下的进程状态：&lt;/h2&gt;

&lt;p&gt;首先查看进程状态的命令PS&lt;/p&gt;

&lt;p&gt;PS的用法：ps  -  parameter&lt;/p&gt;

&lt;p&gt;常用参数：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-A&lt;/code&gt; 显示所有的进程(等价于&lt;code&gt;-e&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-a&lt;/code&gt; 显示一个终端的所有进程&lt;/p&gt;

&lt;p&gt;&lt;code&gt;c&lt;/code&gt;   显示进程的真实名称&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-e&lt;/code&gt;  等价于&lt;code&gt;-A&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-N&lt;/code&gt;  忽略选择&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-d&lt;/code&gt;  显示所有进程，但是省略所有的会话引线&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-x&lt;/code&gt;  显示没有控制终端的进程，同时显示各个命令的具体路径。&lt;code&gt;dx&lt;/code&gt;  不可合用&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-p&lt;/code&gt; pid进程使用cpu时间&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-u&lt;/code&gt; uid or username选择有效的用户id或者用户名&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-g&lt;/code&gt; gid or groupname 显示组的所有进程&lt;/p&gt;

&lt;p&gt;&lt;code&gt;U&lt;/code&gt;  username显示该用户下的所有进程，且显示各个命令的线下路径ps U zhangsan&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-f&lt;/code&gt; 全部列出，通常和显示选项联用。ps -fa or ps -fx&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-m&lt;/code&gt; 显示所有的线程&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-H&lt;/code&gt; 显示进程的层次 ps -Ha&lt;/p&gt;

&lt;hr&gt;


&lt;h4&gt;ps -aux输出格式&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND USER&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;USER&lt;/code&gt; 进程拥有者&lt;/p&gt;

&lt;p&gt;&lt;code&gt;PID&lt;/code&gt; 进程pid&lt;/p&gt;

&lt;p&gt;&lt;code&gt;%CPU&lt;/code&gt; 占用cpu的使用率&lt;/p&gt;

&lt;p&gt;&lt;code&gt;%MEM&lt;/code&gt; 占用内存大小&lt;/p&gt;

&lt;p&gt;&lt;code&gt;VSZ&lt;/code&gt; 占用虚拟内存大小&lt;/p&gt;

&lt;p&gt;&lt;code&gt;RSS&lt;/code&gt;  占用物理内存&lt;/p&gt;

&lt;p&gt;&lt;code&gt;TTY&lt;/code&gt; linux的终端号pts/1&lt;/p&gt;

&lt;hr&gt;


&lt;p&gt;&lt;strong&gt;&lt;code&gt;STAT&lt;/code&gt;  运行的状态：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;D：不可中断终端的休眠状态(IO进程)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;R：正在运行，在可中断队列中&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;S：处于休眠状态，静止状态&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;T：停止或被跟踪，暂停执行&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;W：进入内存交换&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;X：杀死的进程&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Z：僵死进程不存在但暂时无法消除&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;S：进程的领导者(在它之下有子进程)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;l：多进程的(CLONE_THREAD,类似NPTL pthreads)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;+：位于后台的进程组&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;hr&gt;


&lt;h4&gt;Kill终止进程有十几种控制进程的方法&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;kill -STOP [pid]&lt;/code&gt;发送SIGSTOP(17,19,23)停止一个进程，而不消灭这个进程&lt;/p&gt;

&lt;p&gt;&lt;code&gt;kill -CONT [pid]&lt;/code&gt; 发送SIGCONT(19,18,25)重新开始一个停止进程&lt;/p&gt;

&lt;p&gt;&lt;code&gt;kill -KILL [pid]&lt;/code&gt; 发送SIGKILL(9)强迫进程立即停止，不实施清理操作&lt;/p&gt;

&lt;p&gt;&lt;code&gt;kill -9 -1&lt;/code&gt; 终止你拥有的全部进程&lt;/p&gt;

&lt;p&gt;SIGKILL和SIGSTOP信号不能被，封锁或者忽略，但是，其他信号可以&lt;/p&gt;
</description>
                <link>http://yutengwan.github.io/2015/01/23/process_st</link>
                <guid>http://yutengwan.github.io/2015/01/23/process_st</guid>
                <pubDate>2015-01-23T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>C++ extern</title>
                <description>&lt;p&gt;在查看别人C++代码时候，经常看到extern &amp;ldquo;C&amp;rdquo; 这样的代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;C++&quot;&gt;#ifndef STORAGE_INCLUDE_C
#define STORAGE_INCLUDE_C

#ifdef __cplusplus
extern &quot;C&quot; {
#endif
...
...

#ifdef __cplusplus
}
#endif

#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;&lt;p&gt;头文件中编译宏#ifndef STORAGE_INCLUDE_C是为了防止文件被重复引用&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;extern可以置于变量或者函数前，以标示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。此外extern也可用来进行链接指定。&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;通常，在模块的头文件中对本模块提供给其它模块引用的函数和全局变量以关键字extern声明。如果模块B欲引用该模块A中定义的全局变量和函数时只需包含模块A的头文件即可。这样，模块B中调用模块A中的函数时，在编译阶段，模块B虽然找不到该函数，但是并不会报错；它会在连接阶段中从模块A编译生成的目标代码中找到此函数。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;与extern对应的关键字是static，被它修饰的全局变量和函数只能在本模块中使用。因此，一个函数或变量只可能被本模块使用时，其不可能被extern “C”修饰。&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt; 被extern &amp;ldquo;C&quot;修饰的变量和函数按照C语言方式编译和连接。&lt;/p&gt;

&lt;p&gt;作为一种面向对象的语言，C++支持函数重载，而过程式语言C则不支持。函数被C++编译后在符号库中的名字与C语言的不同。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;C&quot;&gt;void foo(int x,int y);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该函数被C编译器编译后在符号库中的名字为&lt;em&gt;foo，而C++编译器则会产生像&lt;/em&gt;foo_int_int之类的名字（不同的编译器可能生成的名字不同，但是都采用了相同的机制，生成的新名字称为“mangled name”）&lt;/p&gt;

&lt;p&gt;foo_int_int这样的名字包含了函数名、函数参数数量及类型信息，C++就是靠这种机制来实现函数重载的。例如，在C++中，函数void foo( int x, int y )与void foo( int x, float y )编译生成的符号是不相同的，后者为_foo_int_float。&lt;/p&gt;

&lt;p&gt;同样地，C++中的变量除支持局部变量外，还支持类成员变量和全局变量。用户所编写程序的类成员变量可能与全局变量同名，我们以&quot;.&amp;ldquo;来区分。而本质上，编译器在进行编译时，与函数的处理相似，也为类中的变量取了一个独一无二的名字，这个名字与用户程序中同名的全局变量名字不同&lt;/p&gt;

&lt;p&gt;在未加extend &amp;ldquo;C&quot;声明时的连接方式：&lt;/p&gt;

&lt;p&gt;假设C++模块A的头文件&quot;moduleA.h&quot;如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;C++&quot;&gt;#ifndef MODULE_A_H
#define MODULE_A_H
int foo(int x,int y);
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在模块B中引用该函数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;C++&quot;&gt;#include &quot;moduleA.h&quot;
foo(2,3);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实际上，在连接阶段，连接器会从模块A生成的目标文件moduleA.o中寻找foo_int_int这样的符号&lt;/p&gt;

&lt;p&gt;在加上extern &amp;ldquo;C&quot;声明后的编译和连接方式：&lt;/p&gt;

&lt;p&gt;加入extern &amp;ldquo;C&quot;声明后，模块A的头文件变为：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;C++&quot;&gt;#ifndef MODULE_A_H
#define MODULE_A_H
extern &quot;C&quot; int foo(int x,inty);
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;模块B中调用foo(2,3)其结果：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;模块A编译生成foo的目标代码时，没有对其名字进行特殊处理，采用的是C语言方式&lt;/li&gt;
&lt;li&gt;连接器在为模板B的目标代码寻找foo(2,3)调用时，寻找的是未经修改过的_foo符号&lt;/li&gt;
&lt;/ul&gt;


&lt;hr /&gt;

&lt;p&gt;如果在模块A中函数声明了foo为extern &amp;ldquo;C&quot;类型，而模块B中包含的是extern int foo( int x, int y ) ，则模块B找不到模块A中的函数；反之亦然。&lt;/p&gt;

&lt;p&gt;用一句话概括extern “C”这个声明的真实目的（任何语言中的任何语法特性的诞生都不是随意而为的，来源于真实世界的需求驱动。我们在思考问题时，不能只停留在这个语言是怎么做的，还要问一问它为什么要这么做，动机是什么，这样我们可以更深入地理解许多问题）:&lt;code&gt;实现C++与C及其它语言的混合编程&lt;/code&gt;&lt;/p&gt;

&lt;h4&gt;extern &amp;ldquo;C&quot;的常用方法&lt;/h4&gt;

&lt;p&gt;C语言头文件：cExample.h&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;C&quot;&gt;#ifndef C_EXAMPLE_H
#define C_EXAMPLE_H
extern int add(int x,int y);
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;C语言实现文件:cExample.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;C&quot;&gt;#include &quot;cExample.h&quot;
int add(int x,int y) 
{
    return x+y;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;C++实现文件:cppFile.cpp&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;C++&quot;&gt;extern &quot;C&quot; 
{
    #include &quot;cExample.h&quot;
}
int main(int argc,char * argv[])
{
    add(2,3);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果C++调用一个C语言编写的.DLL时，当包括.DLL的头文件或声明接口函数时，应加extern &amp;ldquo;C&amp;rdquo; {　}。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;在C中引用C++语言中的函数和变量时，C++的头文件需添加extern &quot;C&quot;，但是在C语言中不能直接引用声明了extern &quot;C&quot;的该头文件，应该仅将C文件中将C++中定义的extern &quot;C&quot;函数声明为extern类型。&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;C++头文件 cppExample.h&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;C++&quot;&gt;#ifndef CPP_EXAMPLE_H
#define CPP_EXAMPLE_H
extern &quot;C&quot; int add(int x,int y);
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;C++实现文件 cppExample.cpp&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;C++&quot;&gt;#include &quot;cppExample.h&quot;
int add(int x,int y) 
{
    return x+y; 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;C实现文件 cFile.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;C&quot;&gt;extern int add(int x,int y);
int main(int argv,char * argv[])
{
    add(2,3);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;cFile编译会出错。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/xulei/archive/2006/11/12/558139.html&quot;&gt;转载：extern &amp;ldquo;C&amp;rdquo;&lt;/a&gt;&lt;/p&gt;
</description>
                <link>http://yutengwan.github.io/2015/01/23/extern_cplusplus</link>
                <guid>http://yutengwan.github.io/2015/01/23/extern_cplusplus</guid>
                <pubDate>2015-01-23T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>my first post</title>
                <description>&lt;h1&gt;my first post&lt;/h1&gt;


&lt;p&gt;This is my first post.Click the link below to go back to index:&lt;/p&gt;


&lt;p&gt;&lt;a href=&quot;/index.html&quot;&gt;Go back&lt;/a&gt;&lt;/p&gt;
</description>
                <link>http://yutengwan.github.io/2015/01/13/first_post</link>
                <guid>http://yutengwan.github.io/2015/01/13/first_post</guid>
                <pubDate>2015-01-13T00:00:00+08:00</pubDate>
        </item>


</channel>
</rss>
