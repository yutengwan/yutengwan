<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>Brady 丶 一点一滴</title>
 <link href="http://yutengwan.github.io/" rel="self"/>
 <link href="http://yutengwan.github.io"/>
 <updated>2015-01-23T09:37:40+08:00</updated>
 <id>http://yutengwan.github.io</id>
 <author>
   <name>yutengwan</name>
   <email>yutengwan@gmail.com</email>
 </author>

 
 <entry>
   <title>C++ extern</title>
   <link href="http://yutengwan.github.io/2015/01/23/extern_cplusplus"/>
   <updated>2015-01-23T00:00:00+08:00</updated>
   <id>http://yutengwan.github.io/2015/01/23/extern_cplusplus</id>
   <content type="html">&lt;p&gt;在查看别人C++代码时候，经常看到extern &amp;ldquo;C&amp;rdquo; 这样的代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;C++&quot;&gt;#ifndef STORAGE_INCLUDE_C
#define STORAGE_INCLUDE_C

#ifdef __cplusplus
extern &quot;C&quot; {
#endif
...
...

#ifdef __cplusplus
}
#endif

#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;&lt;p&gt;头文件中编译宏#ifndef STORAGE_INCLUDE_C是为了防止文件被重复引用&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;extern可以置于变量或者函数前，以标示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。此外extern也可用来进行链接指定。&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;通常，在模块的头文件中对本模块提供给其它模块引用的函数和全局变量以关键字extern声明。如果模块B欲引用该模块A中定义的全局变量和函数时只需包含模块A的头文件即可。这样，模块B中调用模块A中的函数时，在编译阶段，模块B虽然找不到该函数，但是并不会报错；它会在连接阶段中从模块A编译生成的目标代码中找到此函数。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;与extern对应的关键字是static，被它修饰的全局变量和函数只能在本模块中使用。因此，一个函数或变量只可能被本模块使用时，其不可能被extern “C”修饰。&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt; 被extern &amp;ldquo;C&quot;修饰的变量和函数按照C语言方式编译和连接。&lt;/p&gt;

&lt;p&gt;作为一种面向对象的语言，C++支持函数重载，而过程式语言C则不支持。函数被C++编译后在符号库中的名字与C语言的不同。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;C&quot;&gt;void foo(int x,int y);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该函数被C编译器编译后在符号库中的名字为&lt;em&gt;foo，而C++编译器则会产生像&lt;/em&gt;foo_int_int之类的名字（不同的编译器可能生成的名字不同，但是都采用了相同的机制，生成的新名字称为“mangled name”）&lt;/p&gt;

&lt;p&gt;foo_int_int这样的名字包含了函数名、函数参数数量及类型信息，C++就是靠这种机制来实现函数重载的。例如，在C++中，函数void foo( int x, int y )与void foo( int x, float y )编译生成的符号是不相同的，后者为_foo_int_float。&lt;/p&gt;

&lt;p&gt;同样地，C++中的变量除支持局部变量外，还支持类成员变量和全局变量。用户所编写程序的类成员变量可能与全局变量同名，我们以&quot;.&amp;ldquo;来区分。而本质上，编译器在进行编译时，与函数的处理相似，也为类中的变量取了一个独一无二的名字，这个名字与用户程序中同名的全局变量名字不同&lt;/p&gt;

&lt;p&gt;在未加extend &amp;ldquo;C&quot;声明时的连接方式：&lt;/p&gt;

&lt;p&gt;假设C++模块A的头文件&quot;moduleA.h&quot;如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;C++&quot;&gt;#ifndef MODULE_A_H
#define MODULE_A_H
int foo(int x,int y);
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在模块B中引用该函数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;C++&quot;&gt;#include &quot;moduleA.h&quot;
foo(2,3);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实际上，在连接阶段，连接器会从模块A生成的目标文件moduleA.obj中寻找foo_int_int这样的符号&lt;/p&gt;

&lt;p&gt;在加上extern &amp;ldquo;C&quot;声明后的编译和连接方式：&lt;/p&gt;

&lt;p&gt;加入extern &amp;ldquo;C&quot;声明后，模块A的头文件变为：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;C++&quot;&gt;#ifndef MODULE_A_H
#define MODULE_A_H
extern &quot;C&quot; int foo(int x,inty);
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;模块B中调用foo(2,3)其结果：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;模块A编译生成foo的目标代码时，没有对其名字进行特殊处理，采用的是C语言方式&lt;/li&gt;
&lt;li&gt;连接器在为模板B的目标代码寻找foo(2,3)调用时，寻找的是未经修改过的_foo符号&lt;/li&gt;
&lt;/ul&gt;


&lt;hr /&gt;

&lt;p&gt;如果在模块A中函数声明了foo为extern &amp;ldquo;C&quot;类型，而模块B中包含的是extern int foo( int x, int y ) ，则模块B找不到模块A中的函数；反之亦然。&lt;/p&gt;

&lt;p&gt;用一句话概括extern “C”这个声明的真实目的（任何语言中的任何语法特性的诞生都不是随意而为的，来源于真实世界的需求驱动。我们在思考问题时，不能只停留在这个语言是怎么做的，还要问一问它为什么要这么做，动机是什么，这样我们可以更深入地理解许多问题）:&lt;code&gt;实现C++与C及其它语言的混合编程&lt;/code&gt;&lt;/p&gt;

&lt;h4&gt;extern &amp;ldquo;C&quot;的常用方法&lt;/h4&gt;

&lt;p&gt;C语言头文件：cExample.h&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;C&quot;&gt;#ifndef C_EXAMPLE_H
#define C_EXAMPLE_H
extern int add(int x,int y);
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;C语言实现文件:cExample.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;C&quot;&gt;#include &quot;cExample.h&quot;
int add(int x,int y) 
{
    return x+y;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;C++实现文件:cppFile.cpp&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;C++&quot;&gt;extern &quot;C&quot; 
{
    #include &quot;cExample.h&quot;
}
int main(int argc,char * argv[])
{
    add(2,3);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果C++调用一个C语言编写的.DLL时，当包括.DLL的头文件或声明接口函数时，应加extern &amp;ldquo;C&amp;rdquo; {　}。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;在C中引用C++语言中的函数和变量时，C++的头文件需添加extern &quot;C&quot;，但是在C语言中不能直接引用声明了extern &quot;C&quot;的该头文件，应该仅将C文件中将C++中定义的extern &quot;C&quot;函数声明为extern类型。&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;C++头文件 cppExample.h&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;C++&quot;&gt;#ifndef CPP_EXAMPLE_H
#define CPP_EXAMPLE_H
extern &quot;C&quot; int add(int x,int y);
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;C++实现文件 cppExample.cpp&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;C++&quot;&gt;#include &quot;cppExample.h&quot;
int add(int x,int y) 
{
    return x+y; 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;C实现文件 cFile.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;C&quot;&gt;extern int add(int x,int y);
int main(int argv,char * argv[])
{
    add(2,3);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;cFile编译会出错。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/xulei/archive/2006/11/12/558139.html&quot;&gt;转载：extern &amp;ldquo;C&amp;rdquo;&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>进程的状态</title>
   <link href="http://yutengwan.github.io/2015/01/22/process_status"/>
   <updated>2015-01-22T00:00:00+08:00</updated>
   <id>http://yutengwan.github.io/2015/01/22/process_status</id>
   <content type="html">&lt;h2&gt;Linux 下的进程状态：&lt;/h2&gt;

&lt;p&gt;首先查看进程状态的命令PS&lt;/p&gt;

&lt;p&gt;PS的用法：ps  -  parameter&lt;/p&gt;

&lt;p&gt;常用参数：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-A&lt;/code&gt; 显示所有的进程(等价于&lt;code&gt;-e&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-a&lt;/code&gt; 显示一个终端的所有进程&lt;/p&gt;

&lt;p&gt;&lt;code&gt;c&lt;/code&gt;   显示进程的真实名称&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-e&lt;/code&gt;  等价于&lt;code&gt;-A&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-N&lt;/code&gt;  忽略选择&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-d&lt;/code&gt;  显示所有进程，但是省略所有的会话引线&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-x&lt;/code&gt;  显示没有控制终端的进程，同时显示各个命令的具体路径。&lt;code&gt;dx&lt;/code&gt;  不可合用&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-p&lt;/code&gt; pid进程使用cpu时间&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-u&lt;/code&gt; uid or username选择有效的用户id或者用户名&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-g&lt;/code&gt; gid or groupname 显示组的所有进程&lt;/p&gt;

&lt;p&gt;&lt;code&gt;U&lt;/code&gt;  username显示该用户下的所有进程，且显示各个命令的线下路径ps U zhangsan&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-f&lt;/code&gt; 全部列出，通常和显示选项联用。ps -fa or ps -fx&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-m&lt;/code&gt; 显示所有的线程&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-H&lt;/code&gt; 显示进程的层次 ps -Ha&lt;/p&gt;

&lt;hr&gt;


&lt;h4&gt;ps -aux输出格式&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND USER&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;USER&lt;/code&gt; 进程拥有者&lt;/p&gt;

&lt;p&gt;&lt;code&gt;PID&lt;/code&gt; 进程pid&lt;/p&gt;

&lt;p&gt;&lt;code&gt;%CPU&lt;/code&gt; 占用cpu的使用率&lt;/p&gt;

&lt;p&gt;&lt;code&gt;%MEM&lt;/code&gt; 占用内存大小&lt;/p&gt;

&lt;p&gt;&lt;code&gt;VSZ&lt;/code&gt; 占用虚拟内存大小&lt;/p&gt;

&lt;p&gt;&lt;code&gt;RSS&lt;/code&gt;  占用物理内存&lt;/p&gt;

&lt;p&gt;&lt;code&gt;TTY&lt;/code&gt; linux的终端号pts/1&lt;/p&gt;

&lt;hr&gt;


&lt;p&gt;&lt;strong&gt;&lt;code&gt;STAT&lt;/code&gt;  运行的状态：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;D：不可中断终端的休眠状态(IO进程)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;R：正在运行，在可中断队列中&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;S：处于休眠状态，静止状态&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;T：停止或被跟踪，暂停执行&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;W：进入内存交换&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;X：杀死的进程&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Z：僵死进程不存在但暂时无法消除&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;S：进程的领导者(在它之下有子进程)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;l：多进程的(CLONE_THREAD,类似NPTL pthreads)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;+：位于后台的进程组&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;hr&gt;


&lt;h4&gt;Kill终止进程有十几种控制进程的方法&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;kill -STOP [pid]&lt;/code&gt;发送SIGSTOP(17,19,23)停止一个进程，而不消灭这个进程&lt;/p&gt;

&lt;p&gt;&lt;code&gt;kill -CONT [pid]&lt;/code&gt; 发送SIGCONT(19,18,25)重新开始一个停止进程&lt;/p&gt;

&lt;p&gt;&lt;code&gt;kill -KILL [pid]&lt;/code&gt; 发送SIGKILL(9)强迫进程立即停止，不实施清理操作&lt;/p&gt;

&lt;p&gt;&lt;code&gt;kill -9 -1&lt;/code&gt; 终止你拥有的全部进程&lt;/p&gt;

&lt;p&gt;SIGKILL和SIGSTOP信号不能被，封锁或者忽略，但是，其他信号可以&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>my first post</title>
   <link href="http://yutengwan.github.io/2015/01/13/first_post"/>
   <updated>2015-01-13T00:00:00+08:00</updated>
   <id>http://yutengwan.github.io/2015/01/13/first_post</id>
   <content type="html">&lt;h1&gt;my first post&lt;/h1&gt;


&lt;p&gt;This is my first post.Click the link below to go back to index:&lt;/p&gt;


&lt;p&gt;&lt;a href=&quot;/index.html&quot;&gt;Go back&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 
</feed>
